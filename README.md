# Лабораторная работа №3

## Перевод арифметического выражения в постфиксную форму (реализация на основе стеков на линейных односвязных списках)

##*Постановка задачи*

Основная задача: разработать статическую библиотеку, реализующую динамические структуры данных:

- Линейный односвязный список
- Стек, основанный на линейном односвязном списке

Написать тестирующую программу для каждой структуры данных с помощью Google C++ Testing Framework.

Написать приложения для демонстрации работы всех методов стека и списка.

Создать репозиторий на сайте (http://github.com), в котором будут отображены все действия с проектом с соответствущими комментариями.

Разработать релизацию алгоритма перевода арифметического выражения из инфиксной формы в постфиксную. Создать консольное приложение для демонстрации работы алгоритмов, где:
- Входные данные - выражение в инфиксной форме
- Результат - выражение в постфиксной форме

##*Руководство пользователя*

Программа предназначена для перевода арифметического выражения, записанного в инфиксной форме, в обратную постфиксную запись.

Чтобы запустить программу необходимо открыть исполняемый файл **sample_postfix.exe** и следовать инструкциям программы.

Пример:

1) Введите арифметическое выражение и нажмите "Enter"



2) Программа выдаст выражение, записанное в инфиксном виде

3) Далее программа выдаст ваше выражение, но уже в постфиксном виде 

4) Для завершения работы нажмите любую клавишу


##*Руководство программиста*

####Общая структура проекта

- [gtest]- библиотека GoogleTest;
- [src] - директория для размещения файлов исходного кода;
- [include] - директория для размещения заголовочных файлов;
- [samples]- директория для размещения исходных кодов приложений;
- [test] - директория для размещения тестов;
- [sln] - директория с файлими решений.


####Описание структуры программы

Программа состоит из 6 проектов:

* `gtest` - фреймворк Google Test;
* `sample` - статическая библиотека, содержащая объявление и реализацию шаблонных классов *Node*, *List*, *Stack*, а также класса *Postfix*:
	* *Node* - описывает узел списка. Хранит значение ключа и указатель на следующий узел;
	* *List* - класс "список". Агрегирует в себе класс *Node*;
	* *Stack* - класс "стек". Агрегирует в себе класс *List*;
	* *Postfix* - класс для перевода арифметического выражения в постфиксную форму;
* `test_postfix` - консольное приложение для проверки правильности реализации классов *List* и *Stack*.

#### Описание структур данных

###### Структура данных "список"

Односвязный линейный список — динамическая структура данных, имеющая неограниченное количество элементов. Состоит из узлов, каждый из которых содержит данные определенного типа и указатель на следующий элемент списка. Признак конца списка - NULL. Начало списка - указатель на его первый элемент (pFirst). Особенностью списка является хранение элементов в памяти: последовательно идущие элементы могут располагаться в памяти совершенно в другом порядке.


В лабораторной работе реализован класс *List*, содержащий в себе нижеизложенные методы:

- конструктор по умолчанию
- деструктор
- конструктор копирования
- `push` - добавление элемента в начало списка
- `search` - поиск узла с заданным ключом
- `pushafter` - вставка элемента ПОСЛЕ заданного узла
- `pushbefore` - вставка элемента ДО заданного узла
- `pushend` - вставка элемента в конец списка
- `remove` - удаление элемента с заданным ключом
- `getfirst(void) - функция получения указателя на первый элемент списка
- `print` - вывод списка

##### Стек

Стек — динамическая структура данных, которая хранит наборы однотипных элементов и работает по принципу "первый вошел - последний вышел".


В лабораторной работе реализован класс *Stack* (реализован на основе класса *List*), содержащий нижеизложенные методы:

- конструктор по умолчанию
- конструктор копирования
- деструктор
- `isfull` - проверка на полноту
- `insempty` - проверка на пустоту
- `push` - добавление элемента в начало стека
- `pop` - извлечение элемента из начала стека
- `print` - вывод стека


### Описание алгоритмов
##### Алгоритм перевода выражения из инфиксной формы в постфиксную


Каждой операции ставится приоритет с помощью функции `prioritet`:

Операциям умножения * и деления / ставится приоритет 3.
Операциям сложения + и вычитания - ставится приоритет 2.
Операции открывающей скобки ( ставится приоритет 1.
Для остальных операций и для букв ставится приоритет 0.

Выражение просматривается слева-направо. Всего реализовано 4 варианта событий:

Встретился операнд, который добавляется в стек res;

Встретилась операция, которая добавляется в стек oper;

Встретилась операция, приоритет которой выше, чем приоритет операции, лежащей в начале стека oper. В этом случае выполняется функция `ponizhenie`, которая проверяет предыдущие операции в стеке oper и перекладывает их в стек res до тех пор, пока приоритет операции в начале стека oper не будет меньше приоритета заданной операции или пока стек oper не опустеет;

Встретилась операция ")", тогда выполняется функция `skobka`, которая перекладыввает все операции из стека oper в стек res до тех пор, пока не встретится операция "(";


##Заключение
В ходе лабораторной работы была реализована программа для перевода выражения из инфиксной формы в постфиксную. Данная программа была реализована с помощью структуры данных "стек", которая в свою очередь была сделана при помощи структуры "список". Для каждого метода были написаны тесты, проверяющие работоспособность данных методов. Было реализовано консольное приложение, демонстрирующее перевод выражения из инфиксной формы в постфиксную. Все изменения, а также полная версия программы были сделаны при помощи сайта "github.com", позволяющего отслеживать ход изменений, и при утере данных позволяющего восстановить работоспособную версию программы.
